From a6643db108ed5b0e50bb0e45f1e0b7b77f418e22 Mon Sep 17 00:00:00 2001
From: Yanuar Harry <ai.the.smarties.physics@gmail.com>
Date: Sun, 17 Aug 2014 12:02:11 +0200
Subject: [PATCH] Driving Mode

Change-Id: I6cd48b1502af2afc16bddd8f8b71cf4b823df0e2
---
 AndroidManifest.xml                                |   17 +
 res/drawable-hdpi/ic_settings_driving.png          |  Bin 0 -> 1445 bytes
 res/drawable-xhdpi/ic_settings_driving.png         |  Bin 0 -> 1867 bytes
 res/drawable-xxhdpi/ic_settings_driving.png        |  Bin 0 -> 2824 bytes
 res/values/donottranslate.xml                      |    4 +
 res/values/pac_arrays.xml                          |   27 +
 res/values/pac_attrs.xml                           |    1 +
 res/values/pac_strings.xml                         |   85 ++
 res/xml/pac_ui_settings.xml                        |    8 +
 res/xml/tts_notif_settings.xml                     |  138 ++++
 src/com/android/settings/pac/TtsNotification.java  |  376 +++++++++
 .../pac/lsn/AppMultiSelectListPreference.java      |    4 +
 src/com/android/settings/tts/IntentReceiver.java   |   69 ++
 src/com/android/settings/tts/NotifyService.java    |  845 ++++++++++++++++++++
 .../android/settings/tts/TextToSpeechSettings.java |    8 +-
 15 files changed, 1581 insertions(+), 1 deletion(-)
 create mode 100644 res/drawable-hdpi/ic_settings_driving.png
 create mode 100644 res/drawable-xhdpi/ic_settings_driving.png
 create mode 100644 res/drawable-xxhdpi/ic_settings_driving.png
 create mode 100644 res/xml/tts_notif_settings.xml
 create mode 100644 src/com/android/settings/pac/TtsNotification.java
 create mode 100644 src/com/android/settings/tts/IntentReceiver.java
 create mode 100644 src/com/android/settings/tts/NotifyService.java

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 6c488a2..f863d4b 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -73,6 +73,8 @@
     <uses-permission android:name="android.permission.READ_PHONE_BLACKLIST" />
     <uses-permission android:name="android.permission.CHANGE_PHONE_BLACKLIST" />
     <uses-permission android:name="android.permission.CHANGE_HEADS_UP_STATE" />
+    <uses-permission android:name="android.permission.RECEIVE_SMS" />
+    <uses-permission android:name="android.permission.SYSTEM_NOTIFICATION_LISTENER" />
 
     <permission
         android:name="android.permission.REQUEST_SUPERUSER"
@@ -2201,6 +2203,21 @@
             </intent-filter>
         </receiver>
 
+        <receiver android:name=".tts.IntentReceiver" >
+            <intent-filter>
+                 <action android:name="android.intent.action.BOOT_COMPLETED" />
+                 <action android:name="android.intent.action.PHONE_STATE" />
+                 <action android:name="android.provider.Telephony.SMS_RECEIVED" />
+                 <action android:name="android.intent.action.ACTION_POWER_CONNECTED" />
+                 <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" />
+                 <action android:name="com.android.settings.tts.action.SPEAK_NOTIFICATION" />
+                 <action android:name="com.android.settings.tts.action.SPEAK_MUSIC" />
+                 <action android:name="com.android.settings.tts.action.RUN_DRIVEMODE" />
+            </intent-filter>
+        </receiver>
+
+        <service android:name=".tts.NotifyService" />
+
         <provider
             android:name="android.support.v4.content.FileProvider"
             android:authorities="com.android.settings.files"
diff --git a/res/drawable-hdpi/ic_settings_driving.png b/res/drawable-hdpi/ic_settings_driving.png
new file mode 100644
index 0000000000000000000000000000000000000000..a59606f2ec17120b041f30ed5887269d052ca41f
GIT binary patch
literal 1445
zcmV;W1zP%vP)<h;3K|Lk000e1NJLTq001xm001xu1^@s6R|5Hm00006VoOIv0RI60
z0RN!9r;`8x010qNS#tmYL?i$JL?i(~XT($h000McNliru-USd16)Kp|vw;8r1u{uQ
zK~!ko)tYOFRaF$nf9vK*li+K{8FduVs3r@+LP(Gjg`7%FvZ!hNRG%V32#WlW(HlSX
zB?>~UFbEn*i0G*mjwV!0nP$Fl2F=Gz^GeBa@G<`T&^od?o;#j%A2ZB?%RT4Zeg1o`
zz4l)Fzt+Am%Ed|nB552@1xy2KfGK`o1LS}%pa<yo&nckK%>Erw10>x9tN<PW76O$i
zUp)`B0$%{1o7w(hb(^FrN#9B8R`Jp+X_ur~W%q!jiNHGG`GlVbfO9}6&<nKtv=J~F
zxY4K8bobN^2^jAK>&&dX9HZVK=}^K5c1n6h(sD^vDR3rBS|(||q+<zqe@S|@)XKju
zsXx}yQArO=sw)C_nj5|^hJ9YrJEc(ET=`H2Bz;*14{u2rq_-tqR}AQD3GQ872IbAa
z7f3oBH=>wn6Ur$`HNz0$CP?}t*7v(vLGG1wHdKDNcUVb#V{4)@%Lp8ZO`F;gFkphD
zgMl6=Qq2HKZ^Rbtl9A#$lJ1Nx?9FMc4(012I?qWO<DXm+IL$GgZqB<COZo;_=C>!!
zY(@bcP6U<$^L+O;;25wQXfd;{EYZo#Bx#T10sL%ccO^BRBdIH}v@xUNV<l}&2!o-t
zN!sj2X2HHM!1zbfyrf3YNV@Ee2Ayf9?O>*)_6!8>grr+C;LnzHA$Wg%^jppwR00jb
zl*$3CB#li0UI*+1W@i}GI$)Qi`ZUo9SPfJJk5@_>e`O805{H0s;k&>dPe#6X{{EYp
zoesb&fqlT70@vtCV1b!+1ei6z0$@I{1eglk8hh^|P;X}KWBkGNnDUWv6~K?co9-1!
zx&$->zW^@-lZuFxbwHcbg}K1}K*)VI07=xP!gX#Bsq$44jLHE?A4*y*=}(nU+MNZw
zC8<5=KS@>tL>{QgGyk>$2Z4IvMKjwj>6njJIi%Cfwn{n!JS%CVCqqdxJv1Q9We0&z
zfD^z<U=eT`Xm;R9lus5)>H{WtpN|7afTw+s*8x#rnHCyQ9f15`W^4TV1^2{U-$<7F
zg1tST*NTvC;CBxuJ3L^t#lto5gx}VN2843_s>J#Ks=<Eu43h2uJ_BZ!Ncq2k<!07;
zjdn-k4<e4z6FjR<(cx}jQwc|Zi(_6(s$)i9F<>Bz0cIwT|0<CIEoL^DqTOx5bw_AG
zNU*9?vd68!;Swl+)OYeUG9|b^6&lbR^FVD1FPsIomB4@<;Z8gRrI-ZFicg^{d?rXC
z2P8d|l4Mn6Bymc}vnQwQYjL3C1xa&45A*>oeto@j5mI>JB5;rM{jAapEH$&fl<gM<
zbZ2iY@LWZw`#k2RrMokn>z9j8*Gf8)M5l*JXdcU$bW})sFHgBJl9Q4?h^TPJvgXhU
zO_WlGofVkF)=1i(pnR*O85yx6y1ysD`6)|M|80RrG$t7ERDoEZ4wcmBVvF*ObN@*0
zF0ic9A1u^pk)AH3tm2tsBp;dC;X(>qQ!{q_pa+Eck{0@PQ#lG-xrESo23Q-6;!NPz
z0ynASzGD`0l(ij*BGm=pxhy4_q~dO8+7hFCATCWQ-<?==aktp=dSJj>Nl#vD3YDe2
z9s%b$;P@(q0fSz(z^|K9M4QqcaKxrle}Xq2NjhSZw94DG_-Upjtx0G%Rnm&sVlCYf
zQ^IbT?~w0RSENePINy=u^0B1x-ljp)OMcE){zJal0^5*>CJadGk<=mSV#4p2+}IvT
z=kj1|k~C#F>h`1apgX~k5&x^fsQ<IasF(i$7c_41MP?a%00000NkvXXu0mjfY1EaJ

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_settings_driving.png b/res/drawable-xhdpi/ic_settings_driving.png
new file mode 100644
index 0000000000000000000000000000000000000000..20cb52e5082ee05771d1828a4972eb9b8e0cd0e6
GIT binary patch
literal 1867
zcmV-R2ekN!P)<h;3K|Lk000e1NJLTq002M$002M;1^@s6s%dfF00006VoOIv0RI60
z0RN!9r;`8x010qNS#tmYL?i$JL?i(~XT($h000McNliru-USd16%M4#S5N=|2G~hN
zK~#9!?VD+g6-5xo|Aiv5#06PUL0k?+0mXwvF)AMMh<@<+prYT@5HK-BMU8i2jGEvF
z6HlUvSBzIMqNq_4jb~gTqKLtRLnJB^msJ*IW!J@@AE+0{cIM5znR$BzD|wmed0kcA
z)!o%q)z#8&4pwglK!c<al7{<ln52Cp@7pA`N&3xyzxs2tnf=~xB@3JeybY`degk%p
z4LX5#U@h=Ia6y0S^kKj)z$VItZNS~Y;lO~t*zsoIO`wbV!e77#z?43r1Avi|?v!+8
zhU)FUzB?ps@O9oHX|SZBlEz9JBB{xBLmIp!X`Y$=(9@%B{+tDDOc}8iz@5MhU;?mL
z3hh0Calnbbls-wJ|0{4)v|T+RfPugxRT|X}yaS9ViQhiJB3GnI@G3B<Cptd_Sf0>`
zF5o&~T%CB20%rTD$H7`)R6RT2=v!0>JAsw14|-w{8h~ZMp9z9Es9v3KOJI0$FYP>M
zCA4QpsY38+|3?g?R$xLeZ@)u;?-K+us<5_qt^8>W@pZuPK4OD3B<vRJfI)?J2jGD?
z!hO^V{WzwruNNVBc?`kLKvN$TK!cBZ2)E`T)&%?*Lu_In_eBOL*d=3YCG=3tR(EMX
zamY@O*&<)9g}~?-DSp`}y|CK!!L&@y5U^O%xxwerX7+Q54LnNHWDkmLk+jy#mX%0<
zkffj7v8uo)l4h7$cQwR`F?;@vCHW8IfQM6@n-_pdW!UuzO8m$)q<I0tR^ZTr4LJsA
zsnPHM95}Tg-viuOi^6?rNZ$nr>w!HAG~$wi0g!773gO#;Ue)P8Ey3R&k(2oyB}IWA
z%gKM3+btnnmW1$1LIYL-C%9R;XGZ21mK+M3m(g?|=<$Q|Js2AYE&tgCT<NTkG%1D8
za!H>{`oin4HnU%XhMX+v{W|P!mzdd$0k1LM=4p}+mo#0{VJURJmvpq5wf~Dy!gQ&?
z&%k*xo>!MgYMupV0#AA1vR?2mFc)~u74**F|Lxw+H7OD1gTv`F1?Wh^h}7F3=yqi}
z7kHfBg_nV=fG@l}Invgh2{?ZO$AtozQ3U~@+3QXB@;MRP`>S5+{4YRb#jx^kXGi)}
z4bG|5tC+XLBJXjq9(YUA5-(RIxR0a*d&%M*CTYCCAM4LofF;286x;(UFBPpG7p`6-
zX@R6eB+Za?yrf1+NV)@<C234An*0MLtpI-XcHsRuM$%W37D-wu=^9C=2e>0c0fYw;
z8zoJN+Rc8*ImV?uS<<P!EC5OBlC(<F6TT}gm$b>ux*~O62bTLzQGupV07C=9%R;BY
z%sM2k_FwdnWU8dAB+c%@jz2DGzL~AbSpV%n07F9ov<C=-vrsiNe45Si-C|A;bpClW
zn^hyukf7WiD#0x=3Z_=LzlTQu*&H~HLAfmyKvz)#nAz7o(R(v{BL`aO(YD6TfWM+s
zrn1M@2=~;v|8M2Q+czk03I)(6sWU(rorBRsbr!(&dEx?r0J`Irz*g-#tB)#;u{j#p
zD(SsCb$*4UwK?#{NB4b6JK_Y;8eJC-XXaR+-IA`Z*XWyBXAZn$gYstorN#rkDG-U7
zS+d=KLxHw@SS=oq77=PLz__f4(4!?Elw4LzOt7V3Ozz@>oxipq|K~Et1gk`a4=H*E
z0DM$q$3OMRQW3r*V{#f&qr!3L0ymd*F3=n^!$Rl)CZ{D+W#oB9&F2D+xHu*^ue977
zPp654A4=r0cg&eUOQxW1!r9=eBIg4E{kswbu%N6|H(+Vjv%vu|d-+C54+ozoNt#*G
z0CgmMZ+GvqXy?!Hphy%Jo7rcz5J}1pIJkrc-s-eI^cdqZFV8Q5_FlE-2MkEC=-MRR
z9`o1Ik`f@1bdi}Ym2|0>i*~+2Qk+M6ubFMANdPW{CnY@?d~TA|QqoeG>d&K8&b@^t
zlESRDH_Ytryb`UJCAL0qmRMv75FE73&pYx(vc#&*0NlAb#XYDfjFYswppn$={{6NB
z)4ox=BEZvQ{yxdfI@1(uYTApLZI`sacBQ(9%VCY1yOu)-oNZ=TN;)}@4gk*b*j}jM
zIwdt{&1lJ#_hV*T-LLM73sOp2nInB}a~Pki!N^%EDJe8Iv6edonG>H}2*V|P7DM9*
zNv-ZnOvo_$Ch2Klj--WIlpt^*Fx%r6$LXJlb_LdHS1wb1FHmH-FR<0`3+$JGe}4kr
zGfC?lcnR3j>-PmJyMsTo-Wa*d4_}Y)l$q@bb$9xGfT_Sqz-@i<#z>6Ixgev9Tg$b%
zEU>UHcLQ<?qTk*cD_an|=e@xMVf2feqyOI>{vUR8_#4U*AO8GjpD6$U002ovPDHLk
FV1k=Occ1_O

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_settings_driving.png b/res/drawable-xxhdpi/ic_settings_driving.png
new file mode 100644
index 0000000000000000000000000000000000000000..1c25a284acd354e8131eb2632af693029e9935b7
GIT binary patch
literal 2824
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
ag#QBKufz5auDQ$r0000<MNUMnLSTZVxJB0h

literal 0
HcmV?d00001

diff --git a/res/values/donottranslate.xml b/res/values/donottranslate.xml
index e6bd9a6..540420b 100644
--- a/res/values/donottranslate.xml
+++ b/res/values/donottranslate.xml
@@ -33,4 +33,8 @@
         <item>@string/input_method_selector_always_show_value</item>
         <item>@string/input_method_selector_always_hide_value</item>
     </string-array>
+    <!-- DO NOT TRANSLATE. ICU date format for display. -->
+    <string name="tts_date_pattern" translatable="false">ddMMMMyyyy</string>
+    <!-- DO NOT TRANSLATE. ICU weekday format for display -->
+    <string name="tts_weekday_pattern" translatable="false">eeee</string>
 </resources>
diff --git a/res/values/pac_arrays.xml b/res/values/pac_arrays.xml
index 3ade4e7..6d974a7 100644
--- a/res/values/pac_arrays.xml
+++ b/res/values/pac_arrays.xml
@@ -688,4 +688,31 @@
 
     <!-- You better not add new string-arrays here, organize them alphabetically! -->
 
+    <!-- Driving mode -->
+    <string-array name="voice_tts_annoy_notif_entries">
+        <item>@string/voice_tts_annoy_notif_default</item>
+        <item>@string/voice_tts_annoy_notif_3s</item>
+        <item>@string/voice_tts_annoy_notif_5s</item>
+        <item>@string/voice_tts_annoy_notif_10s</item>
+        <item>@string/voice_tts_annoy_notif_15s</item>
+        <item>@string/voice_tts_annoy_notif_30s</item>
+        <item>@string/voice_tts_annoy_notif_45s</item>
+        <item>@string/voice_tts_annoy_notif_1m</item>
+        <item>@string/voice_tts_annoy_notif_2m</item>
+        <item>@string/voice_tts_annoy_notif_5m</item>
+    </string-array>
+
+    <string-array name="voice_tts_annoy_notif_values" translatable="false">
+        <item>0</item>
+        <item>3000</item>
+        <item>5000</item>
+        <item>10000</item>
+        <item>15000</item>
+        <item>30000</item>
+        <item>45000</item>
+        <item>60000</item>
+        <item>120000</item>
+        <item>300000</item>
+    </string-array>
+
 </resources>
diff --git a/res/values/pac_attrs.xml b/res/values/pac_attrs.xml
index b6a28c6..fd0ed5e 100644
--- a/res/values/pac_attrs.xml
+++ b/res/values/pac_attrs.xml
@@ -48,6 +48,7 @@
         <attr name="minimun" format="integer" />
         <attr name="unitsLeft" format="string|reference" />
         <attr name="unitsRight" format="string|reference" />
+        <attr name="interval" format="integer" />
     </declare-styleable>
 
 </resources>
diff --git a/res/values/pac_strings.xml b/res/values/pac_strings.xml
index 2b41e88..883bdab 100644
--- a/res/values/pac_strings.xml
+++ b/res/values/pac_strings.xml
@@ -666,4 +666,89 @@
     <string name="app_circle_bar_included_apps_summary">Apps will show in app circle sidebar</string>
     <string name="title_tile_appcirclebar">App Circle Bar</string>
 
+    <!-- Driving mode -->
+    <!-- require add space in the end of string -->
+    <string name="voice_tts_new_call">Incoming call from </string>
+    <!-- require add space in the end of string -->
+    <string name="voice_tts_new_sms">New text message from </string>
+    <!-- require add space in the end of string -->
+    <string name="voice_tts_new_notif">New notification from </string>
+    <string name="voice_tts_title">Driving Mode</string>
+    <string name="voice_tts_summary">Enable Driving mode then choose what you want to speak while driving</string>
+    <string name="tts_settings_reset_message">Reset all settings to default?</string>
+    <string name="voice_tts_notification_title">Drive mode</string>
+    <string name="voice_tts_notification_summary_on">Enable driving mode</string>
+    <string name="voice_tts_notification_summary_off">Disable driving mode</string>
+    <string name="voice_tts_volume_title">Volume</string>
+    <string name="voice_tts_volume_summary">Set volume for speak</string>
+    <string name="voice_tts_call_title">Incoming call</string>
+    <string name="voice_tts_call_summary">Enable/disable speak for Incoming calls</string>
+    <string name="voice_tts_sms_title">New message</string>
+    <string name="voice_tts_sms_summary">Enable/disable speak for New messages</string>
+    <string name="voice_tts_sms_read_title">Read new message</string>
+    <string name="voice_tts_sms_read_summary">Enable/disable speak for Read New messages</string>
+    <string name="voice_tts_charge_full_title">Battery full indicator</string>
+    <string name="voice_tts_charge_full_summary">Enable/disable speak for battery fully charged</string>
+    <string name="voice_tts_charge_on_title">Connect charger</string>
+    <string name="voice_tts_charge_on_summary">Enable/disable speak for charging connected</string>
+    <string name="voice_tts_charge_off_title">Disconnect charger</string>
+    <string name="voice_tts_charge_off_summary">Enable/disable speak for charging disconnected</string>
+    <string name="voice_tts_clock_title">Clock</string>
+    <string name="voice_tts_clock_summary">Enable/disable speak for clock after screen turn on</string>
+    <string name="voice_tts_date_title">Date</string>
+    <string name="voice_tts_date_summary">Enable/disable speak for date after screen turn on</string>
+    <string name="voice_tts_notif_title">Notification</string>
+    <string name="voice_tts_notif_summary">Enable/disable speak for new notification</string>
+    <string name="voice_tts_notif_read_title">Read new notifications</string>
+    <string name="voice_tts_notif_read_summary">Enable/disable speak for Read New messages from notifications</string>
+    <string name="voice_tts_whitelist_title">Included applications</string>
+    <string name="voice_tts_whitelist_summary">Which apps allowed to speak for new notifications</string>
+    <string name="voice_tts_music_title">Music track</string>
+    <string name="voice_tts_music_summary">Enable/disable speak for song name</string>
+    <string name="voice_tts_annoy_notif_title">Less frequent speak notification</string>
+    <string name="voice_tts_annoy_notif_summary">Limit the speak notification of each app to only play once per set time period</string>
+    <string name="voice_tts_annoy_notif_default">Default Behaviour</string>
+    <string name="voice_tts_annoy_notif_3s">3 seconds</string>
+    <string name="voice_tts_annoy_notif_5s">5 seconds</string>
+    <string name="voice_tts_annoy_notif_10s">10 seconds</string>
+    <string name="voice_tts_annoy_notif_15s">15 seconds</string>
+    <string name="voice_tts_annoy_notif_30s">30 seconds</string>
+    <string name="voice_tts_annoy_notif_45s">45 seconds</string>
+    <string name="voice_tts_annoy_notif_1m">1 minute</string>
+    <string name="voice_tts_annoy_notif_2m">2 minutes</string>
+    <string name="voice_tts_annoy_notif_5m">5 minutes</string>
+    <string name="voice_tts_charge_full">Battery fully charged</string>
+    <string name="voice_tts_charge_on">Charging Start</string>
+    <string name="voice_tts_charge_off">Charging Stop</string>
+    <string name="voice_tts_time">Time is</string>
+    <string name="voice_tts_date">Date is</string>
+    <string name="voice_tts_music">Now playing</string>
+    <string name="voice_tts_engine_started">Drive Mode Ready</string>
+    <string name="unknown_tts">Unknown</string>
+    <string name="unknown_number_tts">Unknown number</string>
+    <string name="time_one">One</string>
+    <string name="time_two">Two</string>
+    <string name="time_three">Three</string>
+    <string name="time_four">Four</string>
+    <string name="time_five">Five</string>
+    <string name="time_six">Six</string>
+    <string name="time_seven">Seven</string>
+    <string name="time_eight">Eight</string>
+    <string name="time_nine">Nine</string>
+    <string name="time_ten">Ten</string>
+    <string name="time_eleven">Eleven</string>
+    <string name="time_twelve">Twelve</string>
+    <string name="time_oclock">o Clock</string>
+    <string name="time_five_past">Five after</string>
+    <string name="time_ten_past">Ten after</string>
+    <string name="time_quarter_past">Quarter after</string>
+    <string name="time_twenty_past">Twenty</string>
+    <string name="time_twenty_five_past">TwentyFive after</string>
+    <string name="time_half_past">Half past</string>
+    <string name="time_twenty_five_to">TwentyFive till</string>
+    <string name="time_twenty_to">Twenty till</string>
+    <string name="time_quarter_to">Quarter till</string>
+    <string name="time_ten_to">Ten till</string>
+    <string name="time_five_to">Five till</string>
+
 </resources>
diff --git a/res/xml/pac_ui_settings.xml b/res/xml/pac_ui_settings.xml
index d668f68..2073172 100644
--- a/res/xml/pac_ui_settings.xml
+++ b/res/xml/pac_ui_settings.xml
@@ -67,4 +67,12 @@
         android:fragment="com.android.settings.mahdi.omni.AppCircleSidebar" >
     </PreferenceScreen>
 
+    <PreferenceScreen
+        android:key="interface_voice_tts"
+        android:icon="@drawable/ic_settings_driving"
+        android:title="@string/voice_tts_title"
+        android:summary="@string/voice_tts_summary"
+        android:fragment="com.android.settings.pac.TtsNotification" >
+    </PreferenceScreen>
+
 </PreferenceScreen>
diff --git a/res/xml/tts_notif_settings.xml b/res/xml/tts_notif_settings.xml
new file mode 100644
index 0000000..6d3724c
--- /dev/null
+++ b/res/xml/tts_notif_settings.xml
@@ -0,0 +1,138 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The OmniROM Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:settings="http://schemas.android.com/apk/res/com.android.settings"
+    android:title="@string/voice_tts_title" >
+
+    <PreferenceScreen android:key="tts_settings_preference"
+        android:fragment="com.android.settings.tts.TextToSpeechSettings"
+        android:title="@string/tts_settings_title"/>
+
+    <SwitchPreference
+        android:key="voice_tts"
+        android:persistent="false"
+        android:title="@string/voice_tts_notification_title"
+        android:summaryOff="@string/voice_tts_notification_summary_off"
+        android:summaryOn="@string/voice_tts_notification_summary_on" />
+
+    <com.android.settings.pac.SeekBarPreferenceCHOS
+        android:key="voice_tts_volume"
+        android:dependency="voice_tts"
+        android:persistent="false"
+        android:title="@string/voice_tts_volume_title"
+        android:summary="@string/voice_tts_volume_summary"
+        android:max="100"
+        settings:min="0"
+        settings:interval="1"
+        settings:unitsLeft=""
+        settings:unitsRight=" %"
+        android:defaultValue="80" />
+
+    <CheckBoxPreference
+        android:key="voice_tts_call"
+        android:persistent="false"
+        android:title="@string/voice_tts_call_title"
+        android:summary="@string/voice_tts_call_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_sms"
+        android:persistent="false"
+        android:title="@string/voice_tts_sms_title"
+        android:summary="@string/voice_tts_sms_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_sms_read"
+        android:persistent="false"
+        android:title="@string/voice_tts_sms_read_title"
+        android:summary="@string/voice_tts_sms_read_summary"
+        android:dependency="voice_tts_sms"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_charge_full"
+        android:persistent="false"
+        android:title="@string/voice_tts_charge_full_title"
+        android:summary="@string/voice_tts_charge_full_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_charge_on"
+        android:persistent="false"
+        android:title="@string/voice_tts_charge_on_title"
+        android:summary="@string/voice_tts_charge_on_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_charge_off"
+        android:persistent="false"
+        android:title="@string/voice_tts_charge_off_title"
+        android:summary="@string/voice_tts_charge_off_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_clock"
+        android:persistent="false"
+        android:title="@string/voice_tts_clock_title"
+        android:summary="@string/voice_tts_clock_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_date"
+        android:persistent="false"
+        android:title="@string/voice_tts_date_title"
+        android:summary="@string/voice_tts_date_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_music"
+        android:persistent="false"
+        android:title="@string/voice_tts_music_title"
+        android:summary="@string/voice_tts_music_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_notif"
+        android:persistent="false"
+        android:title="@string/voice_tts_notif_title"
+        android:summary="@string/voice_tts_notif_summary"
+        android:dependency="voice_tts"/>
+
+    <CheckBoxPreference
+        android:key="voice_tts_notif_read"
+        android:persistent="false"
+        android:title="@string/voice_tts_notif_read_title"
+        android:summary="@string/voice_tts_notif_read_summary"
+        android:dependency="voice_tts_notif"/>
+
+    <com.android.settings.pac.lsn.AppMultiSelectListPreference
+        android:key="voice_tts_whitelist"
+        android:persistent="false"
+        android:dependency="voice_tts_notif"
+        android:title="@string/voice_tts_whitelist_title"
+        android:summary="@string/voice_tts_whitelist_summary" />
+
+    <ListPreference
+        android:key="voice_tts_annoy_notif"
+        android:dependency="voice_tts_notif"
+        android:title="@string/voice_tts_annoy_notif_title"
+        android:summary="@string/voice_tts_annoy_notif_summary"
+        android:entries="@array/voice_tts_annoy_notif_entries"
+        android:entryValues="@array/voice_tts_annoy_notif_values"
+        android:persistent="false"
+        android:defaultValue="0" />
+
+</PreferenceScreen>
diff --git a/src/com/android/settings/pac/TtsNotification.java b/src/com/android/settings/pac/TtsNotification.java
new file mode 100644
index 0000000..dba6ab8
--- /dev/null
+++ b/src/com/android/settings/pac/TtsNotification.java
@@ -0,0 +1,376 @@
+/*
+ * Copyright (C) 2014 The OmniROM Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.pac;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceChangeListener;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceScreen;
+import android.preference.PreferenceManager;
+import android.preference.SwitchPreference;
+import android.provider.Settings;
+import android.speech.tts.TextToSpeech;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+
+import com.android.settings.pac.SeekBarPreferenceCHOS;
+import com.android.settings.pac.lsn.AppMultiSelectListPreference;
+import com.android.settings.SettingsPreferenceFragment;
+import com.android.settings.tts.IntentReceiver;
+import com.android.settings.R;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+public class TtsNotification extends SettingsPreferenceFragment implements
+        OnPreferenceChangeListener {
+
+    private static final String TAG = "TtsNotification";
+    private static final String KEY_VOICE_TTS = "voice_tts";
+    private static final String KEY_VOICE_TTS_VOLUME = "voice_tts_volume";
+    private static final String KEY_VOICE_TTS_CALL = "voice_tts_call";
+    private static final String KEY_VOICE_TTS_SMS = "voice_tts_sms";
+    private static final String KEY_VOICE_TTS_SMS_READ = "voice_tts_sms_read";
+    private static final String KEY_VOICE_TTS_CHARGE_FULL = "voice_tts_charge_full";
+    private static final String KEY_VOICE_TTS_CHARGE_ON = "voice_tts_charge_on";
+    private static final String KEY_VOICE_TTS_CHARGE_OFF = "voice_tts_charge_off";
+    private static final String KEY_VOICE_TTS_CLOCK = "voice_tts_clock";
+    private static final String KEY_VOICE_TTS_DATE = "voice_tts_date";
+    private static final String KEY_VOICE_TTS_MUSIC = "voice_tts_music";
+    private static final String KEY_VOICE_TTS_NOTIF = "voice_tts_notif";
+    private static final String KEY_VOICE_TTS_NOTIF_READ = "voice_tts_notif_read";
+    private static final String KEY_VOICE_TTS_INCLUDED_APPS = "voice_tts_whitelist";
+    private static final String KEY_VOICE_TTS_ANNOY_NOTIF = "voice_tts_annoy_notif";
+
+    private static final int MULTIPLIER_VOLUME = 10;
+
+    private static final int MENU_RESET = Menu.FIRST;
+
+    private SwitchPreference mEnableVoiceTTS;
+    private SeekBarPreferenceCHOS mVoiceVolume;
+    private CheckBoxPreference mEnableVoiceTTScall;
+    private CheckBoxPreference mEnableVoiceTTSsms;
+    private CheckBoxPreference mEnableVoiceTTSsmsRead;
+    private CheckBoxPreference mEnableVoiceTTSchargeFull;
+    private CheckBoxPreference mEnableVoiceTTSchargeOn;
+    private CheckBoxPreference mEnableVoiceTTSchargeOff;
+    private CheckBoxPreference mEnableVoiceTTSclock;
+    private CheckBoxPreference mEnableVoiceTTSdate;
+    private CheckBoxPreference mEnableVoiceTTSmusic;
+    private CheckBoxPreference mEnableVoiceTTSnotif;
+    private CheckBoxPreference mEnableVoiceTTSnotifRead;
+    private AppMultiSelectListPreference mIncludedAppsPref;
+    private ListPreference mAnnoyingNotifications;
+
+    private boolean isEngineReady;
+    private SharedPreferences mShareprefs;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.tts_notif_settings);
+
+        Context context = getActivity();
+        PreferenceScreen prefSet = getPreferenceScreen();
+
+        mShareprefs = PreferenceManager.getDefaultSharedPreferences(context);
+
+        mEnableVoiceTTS = (SwitchPreference) prefSet.findPreference(KEY_VOICE_TTS);
+        mEnableVoiceTTS.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED, false));
+        mEnableVoiceTTS.setOnPreferenceChangeListener(this);
+
+        mVoiceVolume = (SeekBarPreferenceCHOS) prefSet.findPreference(KEY_VOICE_TTS_VOLUME);
+        mVoiceVolume.setValue((mShareprefs.getInt(IntentReceiver.VOICE_VOLUME, 8) * MULTIPLIER_VOLUME));
+        mVoiceVolume.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTScall = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_CALL);
+        mEnableVoiceTTScall.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_CALL, false));
+        mEnableVoiceTTScall.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSsms = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_SMS);
+        mEnableVoiceTTSsms.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_SMS, false));
+        mEnableVoiceTTSsms.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSsmsRead = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_SMS_READ);
+        mEnableVoiceTTSsmsRead.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_SMS_READ, false));
+        mEnableVoiceTTSsmsRead.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSchargeFull = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_CHARGE_FULL);
+        mEnableVoiceTTSchargeFull.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_CHARGE_FULL, false));
+        mEnableVoiceTTSchargeFull.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSchargeOn = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_CHARGE_ON);
+        mEnableVoiceTTSchargeOn.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_CHARGE_ON, false));
+        mEnableVoiceTTSchargeOn.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSchargeOff = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_CHARGE_OFF);
+        mEnableVoiceTTSchargeOff.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_CHARGE_OFF, false));
+        mEnableVoiceTTSchargeOff.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSclock = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_CLOCK);
+        mEnableVoiceTTSclock.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_CLOCK, false));
+        mEnableVoiceTTSclock.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSdate = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_DATE);
+        mEnableVoiceTTSdate.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_DATE, false));
+        mEnableVoiceTTSdate.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSmusic = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_MUSIC);
+        mEnableVoiceTTSmusic.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_MUSIC, false));
+        mEnableVoiceTTSmusic.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSnotif = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_NOTIF);
+        mEnableVoiceTTSnotif.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_NOTIF, false));
+        mEnableVoiceTTSnotif.setOnPreferenceChangeListener(this);
+
+        mEnableVoiceTTSnotifRead = (CheckBoxPreference) prefSet.findPreference(KEY_VOICE_TTS_NOTIF_READ);
+        mEnableVoiceTTSnotifRead.setChecked(mShareprefs.getBoolean(IntentReceiver.ENABLED_NOTIF_READ, false));
+        mEnableVoiceTTSnotifRead.setOnPreferenceChangeListener(this);
+
+        mIncludedAppsPref = (AppMultiSelectListPreference) prefSet.findPreference(KEY_VOICE_TTS_INCLUDED_APPS);
+        Set<String> includedApps = getIncludedApps();
+        if (includedApps != null) mIncludedAppsPref.setValues(includedApps);
+        mIncludedAppsPref.setOnPreferenceChangeListener(this);
+
+        mAnnoyingNotifications = (ListPreference) prefSet.findPreference(KEY_VOICE_TTS_ANNOY_NOTIF);
+        mAnnoyingNotifications.setValue(Integer.toString(
+                   mShareprefs.getInt(IntentReceiver.ANNOYING_NOTIFICATION, 0)));
+        mAnnoyingNotifications.setOnPreferenceChangeListener(this);
+
+        if (!mShareprefs.getBoolean(IntentReceiver.FIRST_BOOT_INUSE, false)) {
+            Intent checkIntent = new Intent();
+            checkIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA);
+            startActivityForResult(checkIntent, 1);
+        }
+
+        checkForEngineReady();
+
+        setHasOptionsMenu(true);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode == 1) {
+            if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) {
+                mShareprefs.edit().putBoolean(IntentReceiver.ENGINE_READY, true).commit();
+                checkForEngineReady();
+                mShareprefs.edit().putBoolean(IntentReceiver.FIRST_BOOT_INUSE, true).commit();
+            } else {
+                // missing data, install it
+                Intent installIntent = new Intent();
+                installIntent.setAction(
+                    TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA);
+                startActivity(installIntent);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENGINE_READY, false).commit();
+                checkForEngineReady();
+            }
+        }
+    }
+
+    private void checkForEngineReady() {
+        isEngineReady = mShareprefs.getBoolean(IntentReceiver.ENGINE_READY, false);
+        mEnableVoiceTTS.setEnabled(isEngineReady);
+        mVoiceVolume.setEnabled(isEngineReady);
+        mEnableVoiceTTScall.setEnabled(isEngineReady);
+        mEnableVoiceTTSsms.setEnabled(isEngineReady);
+        mEnableVoiceTTSsmsRead.setEnabled(isEngineReady);
+        mEnableVoiceTTSchargeFull.setEnabled(isEngineReady);
+        mEnableVoiceTTSchargeOn.setEnabled(isEngineReady);
+        mEnableVoiceTTSchargeOff.setEnabled(isEngineReady);
+        mEnableVoiceTTSclock.setEnabled(isEngineReady);
+        mEnableVoiceTTSdate.setEnabled(isEngineReady);
+        mEnableVoiceTTSmusic.setEnabled(isEngineReady);
+        mEnableVoiceTTSnotif.setEnabled(isEngineReady);
+        mEnableVoiceTTSnotifRead.setEnabled(isEngineReady);
+        mIncludedAppsPref.setEnabled(isEngineReady);
+        mAnnoyingNotifications.setEnabled(isEngineReady);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.add(0, MENU_RESET, 0, R.string.reset)
+                .setIcon(R.drawable.ic_settings_backup) // use the backup icon
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_RESET:
+                resetToDefault();
+                return true;
+            default:
+                return super.onContextItemSelected(item);
+        }
+    }
+
+    private void resetToDefault() {
+        AlertDialog.Builder alertDialog = new AlertDialog.Builder(getActivity());
+        alertDialog.setTitle(R.string.reset);
+        alertDialog.setMessage(R.string.tts_settings_reset_message);
+        alertDialog.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int id) {
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED, false).commit();
+                mEnableVoiceTTS.setChecked(false);
+                mShareprefs.edit().putInt(IntentReceiver.VOICE_VOLUME, 8).commit();
+                mVoiceVolume.setValue(80);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CALL, false).commit();
+                mEnableVoiceTTScall.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_SMS, false).commit();
+                mEnableVoiceTTSsms.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_SMS_READ, false).commit();
+                mEnableVoiceTTSsmsRead.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CHARGE_FULL, false).commit();
+                mEnableVoiceTTSchargeFull.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CHARGE_ON, false).commit();
+                mEnableVoiceTTSchargeOn.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CHARGE_OFF, false).commit();
+                mEnableVoiceTTSchargeOff.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CLOCK, false).commit();
+                mEnableVoiceTTSclock.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_DATE, false).commit();
+                mEnableVoiceTTSdate.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_MUSIC, false).commit();
+                mEnableVoiceTTSmusic.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_NOTIF, false).commit();
+                mEnableVoiceTTSnotif.setChecked(false);
+                mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_NOTIF_READ, false).commit();
+                mEnableVoiceTTSnotifRead.setChecked(false);
+                mShareprefs.edit().putString(IntentReceiver.INCLUDE_NOTIFICATIONS, "").commit();
+                mIncludedAppsPref.setClearValues();
+                mShareprefs.edit().putInt(IntentReceiver.ANNOYING_NOTIFICATION, 0).commit();
+                mAnnoyingNotifications.setValue("0");
+            }
+        });
+        alertDialog.setNegativeButton(R.string.cancel, null);
+        alertDialog.create().show();
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (preference == mEnableVoiceTTS) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED, value ? true : false).commit();
+            if (value) {
+                Intent intent = new Intent(IntentReceiver.ACTION_RUN_DRIVEMODE);
+                getActivity().getApplicationContext().sendBroadcast(intent);
+            }
+            return true;
+        } else if (preference == mVoiceVolume) {
+            int value = ((Integer)newValue).intValue();
+            int val = (value / MULTIPLIER_VOLUME);
+            mShareprefs.edit().putInt(IntentReceiver.VOICE_VOLUME, val).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTScall) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CALL, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSsms) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_SMS, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSsmsRead) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_SMS_READ, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSchargeFull) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CHARGE_FULL, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSchargeOn) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CHARGE_ON, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSchargeOff) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CHARGE_OFF, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSclock) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_CLOCK, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSdate) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_DATE, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSmusic) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_MUSIC, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSnotif) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_NOTIF, value ? true : false).commit();
+            return true;
+        } else if (preference == mEnableVoiceTTSnotifRead) {
+            boolean value = (Boolean) newValue;
+            mShareprefs.edit().putBoolean(IntentReceiver.ENABLED_NOTIF_READ, value ? true : false).commit();
+            return true;
+        } else if (preference == mIncludedAppsPref) {
+            storeIncludedApps((Set<String>) newValue);
+            return true;
+        } else if (preference == mAnnoyingNotifications) {
+            int value = Integer.valueOf((String) newValue);
+            mShareprefs.edit().putInt(IntentReceiver.ANNOYING_NOTIFICATION, value).commit();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
+        // If we didn't handle it, let preferences handle it.
+        return super.onPreferenceTreeClick(preferenceScreen, preference);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+    }
+
+    private Set<String> getIncludedApps() {
+        String included = mShareprefs.getString(IntentReceiver.INCLUDE_NOTIFICATIONS, "");
+        if (TextUtils.isEmpty(included))
+            return null;
+
+        return new HashSet<String>(Arrays.asList(included.split("\\|")));
+    }
+
+    private void storeIncludedApps(Set<String> values) {
+        StringBuilder builder = new StringBuilder();
+        String delimiter = "";
+        for (String value : values) {
+            builder.append(delimiter);
+            builder.append(value);
+            delimiter = "|";
+        }
+        mShareprefs.edit().putString(IntentReceiver.INCLUDE_NOTIFICATIONS, builder.toString()).commit();
+    }
+}
diff --git a/src/com/android/settings/pac/lsn/AppMultiSelectListPreference.java b/src/com/android/settings/pac/lsn/AppMultiSelectListPreference.java
index 55635ee..a29206d 100644
--- a/src/com/android/settings/pac/lsn/AppMultiSelectListPreference.java
+++ b/src/com/android/settings/pac/lsn/AppMultiSelectListPreference.java
@@ -101,6 +101,10 @@ public class AppMultiSelectListPreference extends DialogPreference {
         persistStringSet(values);
     }
 
+    public void setClearValues() {
+        mValues.clear();
+    }
+
     /**
 * Retrieves the current value of the key.
 */
diff --git a/src/com/android/settings/tts/IntentReceiver.java b/src/com/android/settings/tts/IntentReceiver.java
new file mode 100644
index 0000000..bc6d1ca
--- /dev/null
+++ b/src/com/android/settings/tts/IntentReceiver.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 The OmniROM Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.tts;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+public class IntentReceiver extends BroadcastReceiver {
+
+       private static final String TAG = "DriveModeBootReceiver";
+
+       public static final String ACTION_PHONE_STATE = "android.intent.action.PHONE_STATE";
+       public static final String ACTION_SMS_RECEIVED = "android.provider.Telephony.SMS_RECEIVED";
+       public static final String ACTION_RUN_DRIVEMODE = "com.android.settings.tts.action.RUN_DRIVEMODE";
+       public static final String ACTION_RUN_BOOTCOMPLETE = "android.intent.action.BOOT_COMPLETED";
+
+       public static final String FIRST_BOOT_INUSE = "voice_tts_firstboot";
+       public static final String ENABLED = "voice_tts_enabled";
+       public static final String VOICE_VOLUME = "voice_tts_volume_sound";
+       public static final String ENGINE_READY = "engine_tts_ready";
+       public static final String ENABLED_CALL = "voice_tts_call_enabled";
+       public static final String ENABLED_SMS = "voice_tts_sms_enabled";
+       public static final String ENABLED_SMS_READ = "voice_tts_sms_read_enabled";
+       public static final String ENABLED_CHARGE_FULL = "voice_tts_chargefull_enabled";
+       public static final String ENABLED_CHARGE_ON = "voice_tts_chargeon_enabled";
+       public static final String ENABLED_CHARGE_OFF = "voice_tts_chargeoff_enabled";
+       public static final String ENABLED_CLOCK = "voice_tts_clock_enabled";
+       public static final String ENABLED_DATE = "voice_tts_date_enabled";
+       public static final String INCLUDE_NOTIFICATIONS = "voice_tts_apps_include";
+       public static final String ANNOYING_NOTIFICATION = "voice_tts_annoying_notif";
+       public static final String ENABLED_NOTIF = "voice_tts_notif_enabled";
+       public static final String ENABLED_NOTIF_READ = "voice_tts_notif_read_enabled";
+       public static final String ENABLED_MUSIC = "voice_tts_music_enabled";
+
+       @Override
+       public void onReceive(Context context, Intent intent) {
+           if (!PreferenceManager.getDefaultSharedPreferences(context)
+                      .getBoolean(ENGINE_READY, false)) {
+               return;
+           }
+           if (!PreferenceManager.getDefaultSharedPreferences(context)
+                      .getBoolean(ENABLED, false)) {
+               return;
+           }
+
+           Log.i(TAG, "Started");
+           Intent serv = new Intent(context, NotifyService.class);
+           serv.setAction(intent.getAction());
+           serv.putExtras(intent);
+           context.startService(serv);
+       }
+}
diff --git a/src/com/android/settings/tts/NotifyService.java b/src/com/android/settings/tts/NotifyService.java
new file mode 100644
index 0000000..c3b35be
--- /dev/null
+++ b/src/com/android/settings/tts/NotifyService.java
@@ -0,0 +1,845 @@
+/*
+ * Copyright (C) 2014 The OmniROM Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.tts;
+
+import static android.media.AudioManager.STREAM_MUSIC;
+import static android.media.AudioManager.STREAM_NOTIFICATION;
+import static android.media.AudioManager.STREAM_RING;
+import static android.media.AudioManager.STREAM_SYSTEM;
+
+import android.app.INotificationManager;
+import android.app.Notification;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.database.Cursor;
+import android.media.AudioManager;
+import android.media.AudioManager.OnAudioFocusChangeListener;
+import android.media.MediaMetadataRetriever;
+import android.media.RemoteControlClient;
+import android.media.RemoteController;
+import android.net.Uri;
+import android.os.BatteryManager;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.preference.PreferenceManager;
+import android.provider.Contacts;
+import android.provider.ContactsContract.PhoneLookup;
+import android.service.notification.INotificationListener;
+import android.service.notification.StatusBarNotification;
+import android.speech.tts.TextToSpeech;
+import android.speech.tts.UtteranceProgressListener;
+import android.speech.tts.TextToSpeech.OnInitListener;
+import android.speech.tts.TextToSpeech.OnUtteranceCompletedListener;
+import android.telephony.SmsMessage;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Set;
+import java.util.TimeZone;
+
+import libcore.icu.ICU;
+
+import com.android.settings.R;
+
+public class NotifyService extends Service implements OnInitListener, Runnable {
+
+       private static final String TAG = "VoiceService";
+
+       private static final String ACTION_SPEAK_NOTIFICATION
+                      = "com.android.settings.tts.action.SPEAK_NOTIFICATION";
+
+       private static final String ACTION_SPEAK_MUSIC
+                      = "com.android.settings.tts.action.SPEAK_MUSIC";
+
+       private int mServiceStartId = -1;
+
+       private final Date mCurrentTime = new Date();
+
+       private Calendar mCalendar;
+       private SimpleDateFormat mWeekdayFormat;
+       private SimpleDateFormat mDateFormat;
+       private String mLastText;
+
+       private static final String[] PROJECTION =
+            new String[] { PhoneLookup.DISPLAY_NAME };
+       private static final String STREAM_SYSTEM_STR =
+                   String.valueOf(AudioManager.STREAM_SYSTEM);
+       private TextToSpeech mTts;
+       private Intent mIntent;
+       private boolean mIsReady;
+       private int mSysVol;
+       private AudioManager mAudioManager;
+       private static final Object sLock = new Object();
+       private Context mContext;
+       private SharedPreferences mShareprefs;
+
+       private BroadcastReceiver mReceiver = null;
+
+       private boolean mActive = false;
+       private boolean mMusicActive = false;
+       private boolean mClientIdLost = true;
+       private Metadata mMetadata = new Metadata();
+       private String mTrackMusic;
+
+       private RemoteController mRemoteController;
+
+       private HashMap<String, Long> mAnnoyingNotifications = new HashMap<String, Long>();
+
+       private INotificationManager mNM;
+       private INotificationListenerWrapper mNotificationListener;
+       private Set<String> mIncludedApps = new HashSet<String>();
+       private String mNotificationText;
+       private String mNotificationApp;
+
+       /**
+        * Simple class that listens to changes in notifications
+        */
+       private class INotificationListenerWrapper extends INotificationListener.Stub {
+           @Override
+           public void onNotificationPosted(final StatusBarNotification sbn) {
+               if (isValidNotification(sbn)) {
+                   showNotification(sbn);
+               }
+           }
+           @Override
+           public void onNotificationRemoved(final StatusBarNotification sbn) {
+           }
+       }
+
+       private OnAudioFocusChangeListener mAudioFocusListener = new OnAudioFocusChangeListener() {
+            public void onAudioFocusChange(int focusChange) {
+                // hack to get Volume stream focus
+            }
+       };
+
+       @Override
+       public IBinder onBind(Intent intent) {
+           return null;
+       }
+
+       @Override
+       public void onCreate() {
+           super.onCreate();
+           mContext = this;
+           if (mTts == null) {
+               mTts = new TextToSpeech(this, this);
+           }
+
+           mAudioManager = (AudioManager) getSystemService(AUDIO_SERVICE);
+           mRemoteController = new RemoteController(mContext, mRCClientUpdateListener);
+           mAudioManager.registerRemoteController(mRemoteController);
+           mNM = INotificationManager.Stub.asInterface(
+                    ServiceManager.getService(Context.NOTIFICATION_SERVICE));
+           mNotificationListener = new INotificationListenerWrapper();
+
+           mShareprefs = PreferenceManager.getDefaultSharedPreferences(mContext);
+
+           IntentFilter filter = new IntentFilter();
+           filter.addAction(Intent.ACTION_BATTERY_CHANGED);
+           filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
+           filter.addAction(Intent.ACTION_LOCALE_CHANGED);
+           filter.addAction(Intent.ACTION_SCREEN_ON);
+           filter.addAction(Intent.ACTION_SCREEN_OFF);
+           filter.addAction(Intent.ACTION_TIME_CHANGED);
+           filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+           filter.addAction(ACTION_SPEAK_NOTIFICATION);
+           filter.addAction(ACTION_SPEAK_MUSIC);
+           filter.addAction(IntentReceiver.ACTION_RUN_DRIVEMODE);
+           mReceiver = new IntentReceiver();
+           Log.i(TAG, "register Receiver");
+           registerReceiver(mReceiver, filter);
+           registerNotificationListener();
+
+           mCalendar = Calendar.getInstance();
+           mCalendar.setTimeInMillis(System.currentTimeMillis());
+       }
+
+       @Override
+       public void onStart(Intent intent, int startId) {
+           super.onStart(intent, startId);
+           mServiceStartId = startId;
+           mIntent = intent;
+           new Thread(this).start();
+
+           createIncludedAppsSet(mShareprefs.getString(IntentReceiver.INCLUDE_NOTIFICATIONS, ""));
+       }
+
+       private String getSmallTime() {
+           mCalendar.setTimeInMillis(System.currentTimeMillis());
+           int mMinutes = mCalendar.get(mCalendar.MINUTE);
+           int mHour = mCalendar.get(mCalendar.HOUR);
+           String mNextH, mTimeH, mTimeString;
+           String mOclock = mContext.getString(R.string.time_oclock);
+           String mFivePast = mContext.getString(R.string.time_five_past);
+           String mTenPast = mContext.getString(R.string.time_ten_past);
+           String mQuarterPast = mContext.getString(R.string.time_quarter_past);
+           String mTwentyPast = mContext.getString(R.string.time_twenty_past);
+           String mTwentyFivePast = mContext.getString(R.string.time_twenty_five_past);
+           String mHalfPast = mContext.getString(R.string.time_half_past);
+           String mTwentyFiveTo = mContext.getString(R.string.time_twenty_five_to);
+           String mTwentyTo = mContext.getString(R.string.time_twenty_to);
+           String mQuarterTo = mContext.getString(R.string.time_quarter_to);
+           String mTenTo = mContext.getString(R.string.time_ten_to);
+           String mFiveTo = mContext.getString(R.string.time_five_to);
+           String mOne = mContext.getString(R.string.time_one);
+           String mTwo = mContext.getString(R.string.time_two);
+           String mThree = mContext.getString(R.string.time_three);
+           String mFour = mContext.getString(R.string.time_four);
+           String mFive = mContext.getString(R.string.time_five);
+           String mSix = mContext.getString(R.string.time_six);
+           String mSeven = mContext.getString(R.string.time_seven);
+           String mEight = mContext.getString(R.string.time_eight);
+           String mNine = mContext.getString(R.string.time_nine);
+           String mTen = mContext.getString(R.string.time_ten);
+           String mEleven = mContext.getString(R.string.time_eleven);
+           String mTwelve = mContext.getString(R.string.time_twelve);
+
+           //hours
+           if (mHour == 1) { mNextH = mTwo; mTimeH = mOne; }
+           else if(mHour == 2) { mNextH = mThree; mTimeH = mTwo; }
+           else if(mHour == 3) { mNextH = mFour; mTimeH = mThree; }
+           else if(mHour == 4) { mNextH = mFive; mTimeH = mFour; }
+           else if(mHour == 5) { mNextH = mSix; mTimeH = mFive; }
+           else if(mHour == 6) { mNextH = mSeven; mTimeH = mSix; }
+           else if(mHour == 7) { mNextH = mEight; mTimeH = mSeven; }
+           else if(mHour == 8) { mNextH = mNine; mTimeH = mEight; }
+           else if(mHour == 9) { mNextH = mTen; mTimeH = mNine; }
+           else if(mHour == 10) { mNextH = mEleven; mTimeH = mTen; }
+           else if(mHour == 11) { mNextH = mTwelve; mTimeH = mEleven; }
+           else if(mHour == 12 || mHour == 0) { mNextH = mOne; mTimeH = mTwelve; }
+           else { mNextH = mTimeH = mContext.getString(R.string.unknown_tts); }// { mNextH = mOne; mTimeH = mTwelve; }
+
+           //minutes
+           if ( 0  <= mMinutes && mMinutes <= 4  ) mTimeString = mTimeH + " " + mOclock;
+           else if ( 5  <= mMinutes && mMinutes <= 9  ) mTimeString = mFivePast + " " + mTimeH;
+           else if ( 10 <= mMinutes && mMinutes <= 14 ) mTimeString = mTenPast + " " + mTimeH;
+           else if ( 15 <= mMinutes && mMinutes <= 19 ) mTimeString = mQuarterPast + " " + mTimeH;
+           else if ( 20 <= mMinutes && mMinutes <= 24 ) mTimeString = mTimeH + " " + mTwentyPast;
+           else if ( 25 <= mMinutes && mMinutes <= 29 ) mTimeString = mTwentyFivePast + " " + mTimeH;
+           else if ( 30 <= mMinutes && mMinutes <= 34 ) mTimeString = mHalfPast + " " + mTimeH;
+           else if ( 35 <= mMinutes && mMinutes <= 39 ) mTimeString = mTwentyFiveTo + " " + mNextH;
+           else if ( 40 <= mMinutes && mMinutes <= 43 ) mTimeString = mTwentyTo + " " + mNextH;
+           else if ( 44 <= mMinutes && mMinutes <= 47 ) mTimeString = mQuarterTo + " " + mNextH;
+           else if ( 48 <= mMinutes && mMinutes <= 51 ) mTimeString = mTenTo + " " + mNextH;
+           else if ( 52 <= mMinutes && mMinutes <= 55 ) mTimeString = mFiveTo + " " + mNextH;
+           else if ( 56 <= mMinutes && mMinutes <= 60 ) mTimeString = mNextH + " " + mOclock;
+           else { mTimeString = mContext.getString(R.string.unknown_tts); }
+
+           return mContext.getString(R.string.voice_tts_time) + " " + mTimeString;
+       }
+
+        private String getDateString() {
+            if (mDateFormat == null) {
+                final String weekdayFormat = mContext.getString(R.string.tts_weekday_pattern);
+                final String dateFormat = mContext.getString(R.string.tts_date_pattern);
+                final Locale l = Locale.getDefault();
+                String weekdayFmt = ICU.getBestDateTimePattern(weekdayFormat, l.toString());
+                String dateFmt = ICU.getBestDateTimePattern(dateFormat, l.toString());
+
+                mDateFormat = new SimpleDateFormat(dateFmt, l);
+                mWeekdayFormat = new SimpleDateFormat(weekdayFmt, l);
+            }
+
+            mCurrentTime.setTime(System.currentTimeMillis());
+            final String text = mContext.getString(R.string.voice_tts_date)
+                 + " " + mWeekdayFormat.format(mCurrentTime)
+                 + " " + mDateFormat.format(mCurrentTime);
+            if (!text.equals(mLastText)) {
+                mLastText = text;
+                return text;
+            }
+            return mLastText;
+        }
+
+        @Override
+        public void onInit(int status) {
+            mIsReady = true;
+            mTts.setOnUtteranceProgressListener(new UtteranceProgressListener() {
+                     @Override
+                     public void onStart(String utteranceId) {}
+
+                     @Override
+                     public void onError(String utteranceId) {}
+
+                     @Override
+                     public void onDone(String utteranceId) {
+                         resetVolume(utteranceId);
+                     }
+            });
+            synchronized (sLock) {
+                 sLock.notify();
+            }
+        }
+
+        private void resetVolume(String utteranceId) {
+            synchronized (sLock) {
+                 if (utteranceId.equals("call")) {
+                     mAudioManager.setStreamMute(STREAM_RING, false);
+                     mAudioManager.setStreamVolume(STREAM_SYSTEM, mSysVol, 0);
+                 } else if (utteranceId.equals("sms")) {
+                     if (mMusicActive) {
+                         mAudioManager.setStreamMute(STREAM_MUSIC, false);
+                     } else {
+                         mAudioManager.setStreamMute(STREAM_NOTIFICATION, false);
+                     }
+                     mAudioManager.setStreamVolume(STREAM_SYSTEM, mSysVol, 0);
+                 } else if (utteranceId.equals("system")) {
+                     if (mMusicActive) {
+                         mAudioManager.setStreamMute(STREAM_MUSIC, false);
+                     } else {
+                         mAudioManager.setStreamMute(STREAM_NOTIFICATION, false);
+                     }
+                     mAudioManager.setStreamVolume(STREAM_SYSTEM, mSysVol, 0);
+                 } else if (utteranceId.equals("music")) {
+                     mAudioManager.setStreamMute(STREAM_MUSIC, false);
+                     mAudioManager.setStreamVolume(STREAM_SYSTEM, mSysVol, 0);
+                 }
+                 mAudioManager.abandonAudioFocus(mAudioFocusListener);
+            }
+        }
+
+        @Override
+        public void run() {
+            while (!mIsReady) {
+                   synchronized (sLock) {
+                        try {
+                             sLock.wait();
+                        } catch (InterruptedException e) { }
+                   }
+            }
+
+            final String action = mIntent.getAction();
+            if (action == null ) {
+                return;
+            }
+
+            if (action.equals(IntentReceiver.ACTION_RUN_BOOTCOMPLETE)) {
+                Log.i(TAG, "Drive Mode Boot Complete");
+                return;
+            }
+
+            if (mAudioManager.isSilentMode()) {
+                Log.i(TAG, "Not speaking - Silent Mode");
+                return;
+            }
+
+            mMusicActive = mAudioManager.isMusicActive();
+
+            if (mAudioManager.isStreamMute(STREAM_RING)) {
+                mAudioManager.setStreamMute(STREAM_RING, false);
+            } else if (mAudioManager.isStreamMute(STREAM_NOTIFICATION)) {
+                mAudioManager.setStreamMute(STREAM_NOTIFICATION, false);
+            } else if (mAudioManager.isStreamMute(STREAM_MUSIC)) {
+                mAudioManager.setStreamMute(STREAM_MUSIC, false);
+            }
+
+            if (mMusicActive) {
+                mAudioManager.requestAudioFocus(mAudioFocusListener, STREAM_SYSTEM,
+                     AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);
+            } else {
+                mAudioManager.requestAudioFocus(mAudioFocusListener, STREAM_SYSTEM,
+                     AudioManager.AUDIOFOCUS_GAIN);
+            }
+
+            final int voiceVolume = mShareprefs.getInt(IntentReceiver.VOICE_VOLUME, 8);
+
+            if (action.equals(IntentReceiver.ACTION_PHONE_STATE)) {
+                if (mTts.isSpeaking() || !mShareprefs.getBoolean(IntentReceiver.ENABLED_CALL, false)) return;
+                Log.i(TAG, "Speak Phone");
+                TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+                switch (tm.getCallState()) {
+                        case TelephonyManager.CALL_STATE_RINGING:
+                             final AudioManager am = mAudioManager;
+                             final int mode = am.getRingerMode();
+                             if (mode == AudioManager.RINGER_MODE_SILENT ||
+                                 mode == AudioManager.RINGER_MODE_VIBRATE) {
+                                 Log.i(TAG, "Not speaking - volume is 0");
+                                 return;
+                             }
+
+                             final String name = findContactFromNumber(
+                                        mIntent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER));
+
+                             synchronized (sLock) {
+                                  am.setStreamMute(STREAM_RING, true);
+                                  mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                                  am.setStreamVolume(STREAM_SYSTEM,
+                                           voiceVolume, 0);
+                                  HashMap<String, String> ops = new HashMap<String, String>();
+                                  ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "call");
+                                  ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                                  mTts.speak(mContext.getString(R.string.voice_tts_new_call) + name, TextToSpeech.QUEUE_FLUSH, ops);
+                             }
+                             break;
+                 }
+             } else if (action.equals(IntentReceiver.ACTION_SMS_RECEIVED)) {
+                 if (mTts.isSpeaking() || !mShareprefs.getBoolean(IntentReceiver.ENABLED_SMS, false)) return;
+                 Log.i(TAG, "Speak Sms");
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_NOTIFICATION) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 Object[] pdusObj = (Object[]) mIntent.getExtras().get("pdus");
+                 SmsMessage msg = SmsMessage.createFromPdu((byte[]) pdusObj[0]);
+                 final String from = msg.getOriginatingAddress();
+                 final String message = msg.getMessageBody();
+                 final boolean readSms = mShareprefs.getBoolean(IntentReceiver.ENABLED_SMS_READ, false);
+                 final boolean isMusicActive = mMusicActive;
+                 synchronized (sLock) {
+                      if (isMusicActive) {
+                          am.setStreamMute(STREAM_MUSIC, true);
+                      } else {
+                          am.setStreamMute(STREAM_NOTIFICATION, true);
+                      }
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               voiceVolume, 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "sms");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      if (readSms) {
+                          mTts.speak(mContext.getString(R.string.voice_tts_new_sms) + findContactFromNumber(from) + message,
+                                 TextToSpeech.QUEUE_FLUSH, ops);
+                      } else {
+                          mTts.speak(mContext.getString(R.string.voice_tts_new_sms) + findContactFromNumber(from),
+                                 TextToSpeech.QUEUE_FLUSH, ops);
+                      }
+                 }
+             } else if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
+                 if (mTts.isSpeaking() || !mShareprefs.getBoolean(IntentReceiver.ENABLED_CHARGE_FULL, false)) return;
+                 Log.i(TAG, "Speak Battery");
+                 final int status = mIntent.getIntExtra(BatteryManager.EXTRA_STATUS,
+                          BatteryManager.BATTERY_STATUS_UNKNOWN);
+                 if (status != BatteryManager.BATTERY_STATUS_FULL) return;
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_NOTIFICATION) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 final boolean isMusicActive = mMusicActive;
+                 synchronized (sLock) {
+                      if (isMusicActive) {
+                          am.setStreamMute(STREAM_MUSIC, true);
+                      } else {
+                          am.setStreamMute(STREAM_NOTIFICATION, true);
+                      }
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               voiceVolume, 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "system");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      mTts.speak(mContext.getString(R.string.voice_tts_charge_full),
+                                 TextToSpeech.QUEUE_FLUSH, ops);
+                 }
+             } else if (action.equals(Intent.ACTION_POWER_CONNECTED)) {
+                 if (mTts.isSpeaking() || !mShareprefs.getBoolean(IntentReceiver.ENABLED_CHARGE_ON, false)) return;
+                 Log.i(TAG, "Speak Charger connected");
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_NOTIFICATION) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 final boolean isMusicActive = mMusicActive;
+                 synchronized (sLock) {
+                      if (isMusicActive) {
+                          am.setStreamMute(STREAM_MUSIC, true);
+                      } else {
+                          am.setStreamMute(STREAM_NOTIFICATION, true);
+                      }
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               voiceVolume, 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "system");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      mTts.speak(mContext.getString(R.string.voice_tts_charge_on),
+                                 TextToSpeech.QUEUE_FLUSH, ops);
+                 }
+             } else if (action.equals(Intent.ACTION_POWER_DISCONNECTED)) {
+                 if (mTts.isSpeaking() || !mShareprefs.getBoolean(IntentReceiver.ENABLED_CHARGE_OFF, false)) return;
+                 Log.i(TAG, "Speak Charger disconnected");
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_NOTIFICATION) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 final boolean isMusicActive = mMusicActive;
+                 synchronized (sLock) {
+                      if (isMusicActive) {
+                          am.setStreamMute(STREAM_MUSIC, true);
+                      } else {
+                          am.setStreamMute(STREAM_NOTIFICATION, true);
+                      }
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               voiceVolume, 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "system");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      mTts.speak(mContext.getString(R.string.voice_tts_charge_off),
+                                 TextToSpeech.QUEUE_FLUSH, ops);
+                 }
+             } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                 if (mTts.isSpeaking()) return;
+                 final boolean speakClock = mShareprefs.getBoolean(IntentReceiver.ENABLED_CLOCK, false);
+                 final boolean speakDate = mShareprefs.getBoolean(IntentReceiver.ENABLED_DATE, false);
+                 if (!speakClock && !speakDate) return;
+
+                 Log.i(TAG, "Speak Clock or Date screen on");
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_NOTIFICATION) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 final boolean isMusicActive = mMusicActive;
+                 synchronized (sLock) {
+                      if (isMusicActive) {
+                          am.setStreamMute(STREAM_MUSIC, true);
+                      } else {
+                          am.setStreamMute(STREAM_NOTIFICATION, true);
+                      }
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               voiceVolume, 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "system");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      if (speakClock && !speakDate) {
+                          mTts.speak(getSmallTime(), TextToSpeech.QUEUE_FLUSH, ops);
+                      } else if (!speakClock && speakDate) {
+                          mTts.speak(getDateString(), TextToSpeech.QUEUE_FLUSH, ops);
+                      } else if (speakClock && speakDate) {
+                          mTts.speak(getSmallTime() + getDateString(), TextToSpeech.QUEUE_FLUSH, ops);
+                      }
+                 }
+             } else if (action.equals(ACTION_SPEAK_NOTIFICATION)) {
+                 if (mTts.isSpeaking() || !mShareprefs.getBoolean(IntentReceiver.ENABLED_NOTIF, false)) return;
+                 Log.i(TAG, "Speak Notifications");
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_NOTIFICATION) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 if (mNotificationText == null || mNotificationApp == null) {
+                     return;
+                 }
+
+                 final boolean readNotif = mShareprefs.getBoolean(IntentReceiver.ENABLED_NOTIF_READ, false);
+                 final boolean isMusicActive = mMusicActive;
+                 synchronized (sLock) {
+                      if (isMusicActive) {
+                          am.setStreamMute(STREAM_MUSIC, true);
+                      } else {
+                          am.setStreamMute(STREAM_NOTIFICATION, true);
+                      }
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               voiceVolume, 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "system");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      if (readNotif) {
+                          mTts.speak(mContext.getString(R.string.voice_tts_new_notif) + mNotificationApp + mNotificationText,
+                                 TextToSpeech.QUEUE_FLUSH, ops);
+                      } else {
+                          mTts.speak(mContext.getString(R.string.voice_tts_new_notif) + mNotificationApp,
+                                 TextToSpeech.QUEUE_FLUSH, ops);
+                      }
+                 }
+             } else if (action.equals(ACTION_SPEAK_MUSIC)) {
+                 if (mTts.isSpeaking() || !mShareprefs.getBoolean(IntentReceiver.ENABLED_MUSIC, false)) return;
+                 Log.i(TAG, "Speak Music");
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_MUSIC) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 if (mTrackMusic == null) {
+                     return;
+                 }
+
+                 final String trackMusic = mTrackMusic;
+                 synchronized (sLock) {
+                      am.setStreamMute(STREAM_MUSIC, true);
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               voiceVolume, 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "music");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      mTts.speak(mContext.getString(R.string.voice_tts_music) + trackMusic, TextToSpeech.QUEUE_FLUSH, ops);
+                 }
+             } else if (action.equals(IntentReceiver.ACTION_RUN_DRIVEMODE)) {
+                 if (mTts.isSpeaking()) return;
+                 Log.i(TAG, "Speak DriveMode OK");
+                 final AudioManager am = mAudioManager;
+                 if (am.getStreamVolume(STREAM_NOTIFICATION) == 0) {
+                     Log.i(TAG, "Not speaking - volume is 0");
+                     return;
+                 }
+
+                 final boolean isMusicActive = mMusicActive;
+                 synchronized (sLock) {
+                      if (isMusicActive) {
+                          am.setStreamMute(STREAM_MUSIC, true);
+                      } else {
+                          am.setStreamMute(STREAM_NOTIFICATION, true);
+                      }
+                      HashMap<String, String> ops = new HashMap<String, String>();
+                      mSysVol = am.getStreamVolume(STREAM_SYSTEM);
+                      am.setStreamVolume(STREAM_SYSTEM,
+                               am.getStreamMaxVolume(STREAM_SYSTEM), 0);
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, "system");
+                      ops.put(TextToSpeech.Engine.KEY_PARAM_STREAM, STREAM_SYSTEM_STR);
+                      mTts.speak(mContext.getString(R.string.voice_tts_engine_started), TextToSpeech.QUEUE_FLUSH, ops);
+                 }
+             }
+        }
+
+        @Override
+        public void onDestroy() {
+            super.onDestroy();
+            if (mTts != null) {
+                mTts.shutdown();
+                mTts = null;
+            }
+            mAudioManager.abandonAudioFocus(mAudioFocusListener);
+            mDateFormat = null;
+            if (mReceiver != null) unregisterReceiver(mReceiver);
+            unregisterNotificationListener();
+        }
+
+        private String findContactFromNumber(String number) {
+            if (number == null) {
+                return mContext.getString(R.string.unknown_number_tts);
+            }
+            String name = filteredQuery(number);
+            if (name == null && number.charAt(0) == '+') {
+                //convert +<international-code><number> to readable format
+                //<number> is normally 10 digits
+                number = "0" + number.substring(number.length() - 10);
+                name = filteredQuery(number);
+            }
+            return name == null ? number : name;
+        }
+
+        private String filteredQuery(String number) {
+            String result = null;
+            final Uri uri =  PhoneLookup.CONTENT_FILTER_URI;
+            final Uri filtered = Uri.withAppendedPath(uri, number);
+            Cursor nameCursor = getContentResolver().query(filtered,
+                          PROJECTION, null, null, null);
+            final String column = PhoneLookup.DISPLAY_NAME;
+            if (nameCursor.moveToFirst()) {
+                result = nameCursor.getString(
+                          nameCursor.getColumnIndex(column));
+            }
+            nameCursor.close();
+            return result;
+        }
+
+        private void showNotification(StatusBarNotification sbn) {
+            mNotificationText = getNotificationText(sbn).toString();
+            mNotificationApp = getAppName(sbn.getPackageName());
+            Intent intent = new Intent(ACTION_SPEAK_NOTIFICATION);
+            mContext.sendBroadcast(intent);
+        }
+
+        private boolean isValidNotification(StatusBarNotification sbn) {
+            return mIncludedApps.contains(sbn.getPackageName())
+                   && !notificationIsAnnoying(sbn.getPackageName());
+        }
+
+        private void createIncludedAppsSet(String includedApps) {
+            if (TextUtils.isEmpty(includedApps))
+                return;
+            String[] appsToInclude = includedApps.split("\\|");
+            mIncludedApps = new HashSet<String>(Arrays.asList(appsToInclude));
+        }
+
+        private String getAppName(String packageName) {
+            PackageManager packageManager = mContext.getPackageManager();
+            ApplicationInfo applicationInfo = null;
+            try {
+                 applicationInfo = packageManager.getApplicationInfo(packageName, 0);
+            } catch (NameNotFoundException nnfe) {}
+            return (String)((applicationInfo != null) ? packageManager.getApplicationLabel(applicationInfo) : "???");
+        }
+
+        private CharSequence getNotificationText(StatusBarNotification sbn) {
+            final Notification notificiation = sbn.getNotification();
+            CharSequence tickerText = notificiation.tickerText;
+            if (tickerText == null) {
+                Bundle extras = notificiation.extras;
+                if (extras != null)
+                    tickerText = extras.getCharSequence(Notification.EXTRA_TITLE, null);
+            }
+            return tickerText != null ? tickerText : "";
+        }
+
+        private boolean notificationIsAnnoying(String pkg) {
+            int getLongThreshold = mShareprefs.getInt(IntentReceiver.ANNOYING_NOTIFICATION, 0);
+            final long annoyingNotificationThreshold = ((long) getLongThreshold);
+
+            if (annoyingNotificationThreshold == 0) {
+                return false;
+            }
+
+            if ("android".equals(pkg)) {
+                return false;
+            }
+
+            long currentTime = System.currentTimeMillis();
+            if (mAnnoyingNotifications.containsKey(pkg)
+                && (currentTime - mAnnoyingNotifications.get(pkg)
+                        < annoyingNotificationThreshold)) {
+                // less than threshold; it's an annoying notification!!
+                return true;
+            } else {
+                // not in map or time to re-add
+                mAnnoyingNotifications.put(pkg, currentTime);
+                return false;
+            }
+        }
+
+        private void registerNotificationListener() {
+            ComponentName cn = new ComponentName(mContext, getClass().getName());
+            try {
+                 mNM.registerListener(mNotificationListener, cn, UserHandle.USER_ALL);
+            } catch (RemoteException e) {
+                 Log.e(TAG, "registerNotificationListener()", e);
+            }
+        }
+
+        private void unregisterNotificationListener() {
+            if (mNotificationListener != null) {
+                try {
+                     mNM.unregisterListener(mNotificationListener, UserHandle.USER_ALL);
+                } catch (RemoteException e) {
+                     Log.e(TAG, "registerNotificationListener()", e);
+                }
+            }
+        }
+
+        private void updateMusicResources() {
+            mTrackMusic = mMetadata.trackTitle;
+            if (mTrackMusic == null || !mActive) return;
+            Intent intent = new Intent(ACTION_SPEAK_MUSIC);
+            mContext.sendBroadcast(intent);
+        }
+
+        private void playbackStateUpdate(int state) {
+            boolean active;
+            switch (state) {
+                 case RemoteControlClient.PLAYSTATE_PLAYING:
+                      active = true;
+                      break;
+                 case RemoteControlClient.PLAYSTATE_ERROR:
+                 case RemoteControlClient.PLAYSTATE_PAUSED:
+                 default:
+                      active = false;
+                      break;
+            }
+            if (active != mActive) {
+                mActive = active;
+                updateMusicResources();
+            }
+        }
+
+        private RemoteController.OnClientUpdateListener mRCClientUpdateListener =
+                   new RemoteController.OnClientUpdateListener() {
+
+            private String mCurrentTrack = null;
+
+            @Override
+            public void onClientChange(boolean clearing) {
+                if (clearing) {
+                    mMetadata.clear();
+                    mCurrentTrack = null;
+                    mActive = false;
+                    mClientIdLost = true;
+                    updateMusicResources();
+                }
+            }
+
+            @Override
+            public void onClientPlaybackStateUpdate(int state, long stateChangeTimeMs,
+                      long currentPosMs, float speed) {
+                mClientIdLost = false;
+                playbackStateUpdate(state);
+            }
+
+            @Override
+            public void onClientPlaybackStateUpdate(int state) {
+                mClientIdLost = false;
+                playbackStateUpdate(state);
+            }
+
+            @Override
+            public void onClientMetadataUpdate(RemoteController.MetadataEditor data) {
+                mMetadata.trackTitle = data.getString(MediaMetadataRetriever.METADATA_KEY_TITLE,
+                       mMetadata.trackTitle);
+                mClientIdLost = false;
+                if ((mMetadata.trackTitle != null
+                       && !mMetadata.trackTitle.equals(mCurrentTrack))) {
+                    mCurrentTrack = mMetadata.trackTitle;
+                    updateMusicResources();
+                }
+            }
+
+            @Override
+            public void onClientTransportControlUpdate(int transportControlFlags) {
+            }
+        };
+
+
+        class Metadata {
+            private String trackTitle;
+
+            public void clear() {
+                trackTitle = null;
+            }
+        }
+}
diff --git a/src/com/android/settings/tts/TextToSpeechSettings.java b/src/com/android/settings/tts/TextToSpeechSettings.java
index 0ff7f4f..13351ba 100644
--- a/src/com/android/settings/tts/TextToSpeechSettings.java
+++ b/src/com/android/settings/tts/TextToSpeechSettings.java
@@ -25,13 +25,16 @@ import com.android.settings.tts.TtsEnginePreference.RadioButtonGroupState;
 
 import android.app.AlertDialog;
 import android.content.ActivityNotFoundException;
+import android.content.Context;
 import android.content.ContentResolver;
 import android.content.Intent;
+import android.content.SharedPreferences;
 import android.os.Bundle;
 import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.PreferenceActivity;
 import android.preference.PreferenceCategory;
+import android.preference.PreferenceManager;
 import android.provider.Settings;
 import android.provider.Settings.SettingNotFoundException;
 import android.speech.tts.TextToSpeech;
@@ -80,7 +83,7 @@ public class TextToSpeechSettings extends SettingsPreferenceFragment implements
     private ListPreference mDefaultRatePref;
     private Preference mPlayExample;
     private Preference mEngineStatus;
-
+    private SharedPreferences mShareprefs;
     private int mDefaultRate = TextToSpeech.Engine.DEFAULT_RATE;
 
     /**
@@ -148,6 +151,8 @@ public class TextToSpeechSettings extends SettingsPreferenceFragment implements
 
         getActivity().setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
 
+        mShareprefs = PreferenceManager.getDefaultSharedPreferences(getActivity().getApplicationContext());
+
         mPlayExample = findPreference(KEY_PLAY_EXAMPLE);
         mPlayExample.setOnPreferenceClickListener(this);
         mPlayExample.setEnabled(false);
@@ -451,6 +456,7 @@ public class TextToSpeechSettings extends SettingsPreferenceFragment implements
     }
 
     private void updateWidgetState(boolean enable) {
+        mShareprefs.edit().putBoolean(IntentReceiver.ENGINE_READY, enable ? true : false).commit();
         mPlayExample.setEnabled(enable);
         mDefaultRatePref.setEnabled(enable);
         mEngineStatus.setEnabled(enable);
-- 
1.7.9.5

